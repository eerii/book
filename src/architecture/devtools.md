# DevTools

The integration for Firefox DevTools lives in multiple parts of the engine:

- The server code is located in `devtools`.
- Type definitions used outside of the `devtools` crate are located in `shared/devtools`. This ensures that the crate can be modified independently of Servo.
- The DevTools server interfaces with code in `script/devtools` to be able to retrieve information on the state of the engine. It does so using an IPC channel to send requests.

## Actors

An Actor can receive and send messages through the DevTools protocol. All incoming messages must have a `to` field with the name of the actor they are addressed to. Each actor can handle some types of messages. This is done in the `handle_message` function of each actor, inside a `match` expression that filters the messages using their `type` field.

The actors are organized in a hierarchy, based on which actor registers which. Actors can be accessed by their name, which is an unique combination of the type of the actor and an incrementing id automatically generated by `ActorRegistry::new_name`.

Servo tries to follow the conventions defined by Firefox own implementation of the DevTools server, so naming and structure is similar to the ones defined [there](https://firefox-source-docs.mozilla.org/devtools/backend/actor-hierarchy.html). However, not all actors are fully implemented at the moment. Here is a list of the current actors and their functions:

- Root:
  - Tab descriptor:

- Other actors
- Diagrams

## Where to find information

The most reliable place to find information on the protocol is the original [source code](https://searchfox.org/mozilla-central/source/devtools/server). The `actors` folder contains files for every actor defined, which have many helpful comments explaining what every method does. Their implementation handles actors and messages differently. The `form` method returns the message that represents the actor itself. The equivalent in Servo is the `encodable` method, paired with the `<Name>ActorMsg` struct, but not all actors have one since it is not necessary. The other methods are the messages that the actor can handle, excluding those that start with an underscore. This maps directly to the `match` statement in `handle_message`. Despite this differences, the in code documentation is the best resource to understand the protocol.

The next best place to look is the [official documentation](https://firefox-source-docs.mozilla.org/devtools/index.html), which contains writeups on the RPD ([Remote Debugging Protocol](https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html)) and the API. These give a very good overview, but for specific actor functionality it is still better to refer to the code comments.

Another helpful resource was the [geckordp](https://github.com/jpramosi/geckordp) repository, a reimplementation of Firefox's side of the DevTools RPD. Not only is it useful to test certain features in Servo by crafting specific queries, but their developer documentation is very simple to understand.

TODO: Event messages

## How to debug messages

An important step when developing this part of the engine is being able to see the messages being sent and received through the RPD protocol. Servo can easily show these by enabling the correct [logging level](https://docs.rs/env_logger/latest/env_logger/#enabling-logging) when running the browser. For example, this will show DevTools messages that match the "debug" level or higher, and set the minimum for other crates to "error".

```sh
RUST_LOG="error,devtools=debug" ./mach run --devtools=6080
```

This is an example of how the logs look:

```
[DEBUG devtools::protocol] {"type":"getRoot","to":"root"}
[DEBUG devtools::protocol] <- {"from":"root","selected":0,"performanceActor":"performance0","deviceActor":"device1","preferenceActor":"preference2"}
[DEBUG devtools::protocol] {"type":"getDescription","to":"device1"}
[DEBUG devtools::protocol] <- {"from":"device1","value":{"apptype":"servo","version":"0.0.1","appbuildid":"20240904155424","platformversion":"125.0","brandName":"Servo"}}
[DEBUG devtools::actors::console] unrecognized message type requested: "LogMessage"
```

The messages that have an arrow (`<-`) are the responses from Servo to the browser, while the ones without it are the requests from the browser. The latter always contain the `type` of the message and which actor they are sent `to`. They will also show if a message sent to an actor is unrecognized. This usually means that this feature is not handled yet, and that it should be added to the `match` statement of the actor.

These logs can be very useful for checking that everything is encoded correctly. However, when it comes to knowing what a new message looks like, it can be helpful to look at how it is supposed to look. For this, we can inspect the connection between two instances of Firefox. One of them is the same that we configured before, and the other one is replacing Servo as the devtools server.

For this we first need to configure this new instance. One vital issue is that it requires a different profile than the other instance. For this, you can use the [developer version of Firefox](CITATION), which already comes with a different profile, or create one (TODO: INSERT INSTRUCTIONS). Assumming that your profile is called `debug` and it is located in the default directory, you can start this new instance as follows:

```sh
firefox --new-instance --start-debugger-server 6080 --profile ~/.mozilla/firefox/debug
```

TODO: ABOUT::CONFIG

- Debug logs servo
- Using wireshark
- Browser console

## Write messages in rust

To convert Rust data to JSON messages we use [serde](CITATION). Using the `Serialize` derive macro it can do it automatically for us. Replies are sent from each of the `handle_message` branches, using the `TcpStream::write_json_packet` function, which takes a serializable item as the parameter.

```rust
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct SomeReply {
    from: String,
    #[serde(rename = "type")]
    type_: String,
    long_variable: u32,
    #[serde(rename = "browsingContextID")]
    browsing_context_id: u32,
}
```

```json
{
    from: "",
    type: "",
    longVariable: 0,
    browsingContextID: 0
}
```

## Communication between devtools and script

## API Changes

- Which version are we targeting
